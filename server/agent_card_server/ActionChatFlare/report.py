from chatflare.graph.action import BaseAction
from chatflare.prompt.base import PromptTemplate
from chatflare.tracker.base import Blob, Commit
from chatflare.core.llm_wrapper import BaseChain
from chatflare.model.openai import ChatOpenAI
from chatflare.model.llama_bedrock import LlamaBedrock


from agent_card_server.Output.print import log_action, log_action_res, COLOR_INCLUDE, COLOR_EXCLUDE, log_errors

import json
import copy


SUMMARY_PROMPT_PREFIX = """You are a research agent specialized in summarizing and synthesizing information to generate a comprehensive biomedical systematic review report. Your task involves working with a set of intermediate synthesis that have been generated from various articles and potentially also some paper summaries that have not been integrated.
All of these summaries are related to this specific research question "{{query}}".

Given a set of summaries that are generated by one or multiple agents, your job is to review these previously generated summaries and synthesize them into a comprehensive report in a clear and coherent manner, organized as a report with findings, analysis, and conclusions.

Itâ€™s important to note:
- When synthesizing, only present information that can be supported by the provided paper summaries or intermediate synthesis.
- When synthesizing, for information comes from paper summaries, cite these paper with the paper index. For information from existing intermediate synthesis, ensure that the generated final report integrates all the evidence from existing synthesis and cite all evidence in the final report. Do not cite existing synthesis in the report, instead stick to the original evidence citations.
- Include citations in the specified format <citation>citation_number</citation> where "citation_number" corresponds to the ID of the paper summary, or the cited evidence ID from the existing synthesis.


Here are all previously generated synthesis and summaries that you need to review and synthesis. Each summary is given in the format of "ID: Summary" and all summaries are wrapped between a pair of triple backticks:
```
{{previous_summaries}}
```

{{user_instructions_potentially_related}}
Begin by integrating user's research question "{{query}}" and instructions (feedback) into your evaluation criteria. If there are no additional instructions or if the instructions or the feedbacks you considered is irrelevant to the summary task, you can ignore them. 
Review the listed summaries to synthesize them into a new, integrated summary. 

You must structure the synthesized summary as follows (in HTML format, each section title should be in bold and followed by a colon, and the content should be in plain text format not `h`):
1. **Introduction**: Introduce the research question and the broader context. Clearly state what the question aims to address.
2. **Study Design**: Describe how the included summaries were selected and any criteria for inclusion or exclusion of studies. Do not mention any search strategy. Instead, highlight the inclusion-exclusion criteria utilized to determine which studies are integrated. Mention that the following inclusion-exclusion criteria were applied: {{inclusion_exclusion_criteria}}.
3. **Key Findings**: Present the core insights and findings from all evidences in a cohesive manner. Integrate the findings, highlighting similarities, differences, patterns, and contradictions. Ensure every piece of integrated information is properly cited, and similar as well as contradictory findings are clearly summarized.  
4. **Conclusion**: Summarize the overall conclusions drawn from the integrated findings. Analyze the findings to discuss their implications, any patterns or trends, and how they address (or fail to address) the research question.
5. **Discussion**: Discuss the strength of the evidence presented, highlight any gaps or missing information, note limitations, and suggest directions for further research or areas where additional studies might be needed. Also, indicate if some aspects could not be fully addressed given the provided summaries and may require consulting the full articles.

Make sure to integrate all previous findings and cite evidence in the form of <citation>citation_number</citation> at the end of sentences where information is used. 
Ensure to cite the original evidence from existing synthesis. 

Be comprehensive and thorough in presenting the integrated summary. Use plain text for the content, but retain the HTML tags for each section. Each section should start with a bold title as per the instructions. Avoid overly brief or cursory explanations.
If no relevant summaries are identified, clearly explain this outcome and provide reasons. In that case, the synthesized summary should still follow the same structure but state there are no relevant external findings.

Use information only from the summaries provided and DO NOT introduce or guess new information!

{RESPONSE_FORMAT}
"""

SUMMARY_RESPONSE_FORMAT = """
When responding use a JSON object formatted in the \
following schema:
```json
{{  
    "reasoning": str, //your analysis and synthesis stragegy here
    "synthesized_summary": str, //the new, comprehensive summary that integrates key information and insights from Summary A and the identified relevant summaries, including citations as <citation>citation_number</citation> (MUST use this format!!!) at the end of sentences where information from the relevant summaries is used
}}
```
"""


def create_report_chain(model_name='gpt-4o-mini'):
    prompt_prefix = SUMMARY_PROMPT_PREFIX.\
        format(RESPONSE_FORMAT=SUMMARY_RESPONSE_FORMAT)
    prompt = PromptTemplate(template=prompt_prefix)
    if "llama" in model_name:
        model = LlamaBedrock(model_name=model_name)
    elif 'gpt' in model_name:
        model = ChatOpenAI(model_name=model_name)
    else: 
        model = ChatOpenAI(model_name=model_name)
    chain = BaseChain(model, prompt, json_mode=True)
    return chain


class ReportGenerationAction(BaseAction):
    def __init__(self, action_name="report_generation", model_name: str=None):
        if model_name is None: 
            runnable = create_report_chain()
        else: 
            runnable = create_report_chain(model_name=model_name)
        super().__init__(action_name, runnable)

    def switch_runnable_model(self, model_name: str):
        self.runnable = create_report_chain(model_name=model_name)

    async def arun(self, agents, cardId: str, client_handler, query=None, inclusion_exclusion_criteria=None, user_specified_requirement=None, summarization_requirement=None):
        """

        """

        log_action("generate final report", 0)

        if len(agents) <= 0:
            log_errors("No agent found to generate report")
            return

        previous_summaries_raw = []
        for agent in agents:
            previous_summaries_raw.extend(
                agent.active_thread.graph_state.memory.get_inner_memories())
        print(previous_summaries_raw)
        inclusion_exclusion_criteria = inclusion_exclusion_criteria or agents[
            0].active_thread.task.in_criteria

        previous_summaries_dict = {
            doc.docstore_id: doc for doc in previous_summaries_raw}

        previous_summaries = "\n".join(
            [f"{doc.docstore_id}: ({'paper-summary' if doc.children is None or len(doc.children)==0 else 'intermediate-synthesis'})-{doc.page_content}" for idx,
                doc in enumerate(previous_summaries_raw)]
        )
        print(previous_summaries)
        if user_specified_requirement is None:
            user_instructions_potentially_related = ""
            if agents[0].active_thread.graph_state.memory.inspiration_conversation_history:
                user_instructions_potentially_related = f"Your thought from previous discussion/feedback from user (may not relevant to current synthesize): {agents[0].active_thread.graph_state.memory.inspiration_conversation_history}"
            else:
                user_instructions_potentially_related = "No additional instructions or feedback from user."

        client_handler.emitOverallSummarizationProgress({
            "globalCardId": cardId,
            "working_status": "start-summarize",
        })


        query = query or agents[0].active_thread.task.research_query
        print("before summarization between agents")
        output = await self.runnable.apredict(
            previous_summaries=previous_summaries,
            query=query,
            user_instructions_potentially_related=user_instructions_potentially_related,
            inclusion_exclusion_criteria=inclusion_exclusion_criteria
        )
        print("after summarization between agents")

        self.sync_with_thread(output, agents, cardId, client_handler)
        return output

    def run(self, thread):
        """

        """
        log_action("synthesis", len(thread.branch.commits)-1)

        if len(thread.graph_state.cached_work['papers_to_read']) == 0 or len(thread.graph_state.memory.docstore._dict) < 2:
            log_errors(
                "No working summary found in memory or not enough summaries to summarize")
            return

        if len(thread.graph_state.cached_work['papers_to_synthesize']) > 2:
            log_errors(
                "More then 2 papers find need to get synthesized, check reason!")
        paper_to_synthesize_id = thread.graph_state.cached_work['papers_to_synthesize'][-1]
        thread.graph_state.cached_work['papers_to_synthesize'] = []
        last_paper_summary_doc = thread.graph_state.memory.docstore._dict[paper_to_synthesize_id]

        previous_summaries_raw = thread.graph_state.memory.associate_in_memory(
            last_paper_summary_doc.page_content)

        for doc, score in previous_summaries_raw:
            if doc.docstore_id == last_paper_summary_doc.docstore_id:
                previous_summaries_raw.remove((doc, score))
                break

        previous_summaries_dict = {
            doc.docstore_id: doc for doc, score in previous_summaries_raw}

        previous_summaries = "\n".join(
            [f"{doc.docstore_id}: {doc.page_content}" for idx,
                (doc, score) in enumerate(previous_summaries_raw)]
        )

        user_instructions_potentially_related = ""
        if thread.graph_state.memory.inspiration_conversation_history:
            user_instructions_potentially_related = f"Your thought from previous discussion/feedback from user (may not relevant to current synthesize): {thread.graph_state.memory.inspiration_conversation_history}"
        else:
            user_instructions_potentially_related = "No additional instructions or feedback from user."

        output = self.runnable.apredict(
            paper_summary=last_paper_summary_doc.page_content,
            previous_summaries=previous_summaries,
            query=thread.task.research_query,
            user_instructions_potentially_related=user_instructions_potentially_related,
            current_summary_index=paper_to_synthesize_id)

        self.sync_with_thread(output, last_paper_summary_doc,
                              previous_summaries_dict, thread)
        if self.runnable.JSON_MODE:
            return json.loads(output)
        return output

    # (output, agents, cardId, client_handler)
    def sync_with_thread(self, output, agents, cardId, client_handler):
        """
        """
        reasoning = output.get("reasoning", "")
        synthesized_summary = output.get("synthesized_summary", "")

        for agent in agents:
            synthesize_result_obj = {
                "agentId": agent.agent_id,
                "output": output,
                "content": synthesized_summary,
                "meta": {
                    "thought": reasoning,
                    "agents": [agent.agent_id for agent in agents],
                    "cardId": cardId
                },
                "update_longterm_memory": False,
                "agent_current_position": agent.active_thread.graph_state.agent_current_position,
                "cached_work": copy.deepcopy(agent.active_thread.graph_state.cached_work)
            }
            synthesis_result_blob = Blob("report", synthesize_result_obj)
            commit = Commit.from_blobs([synthesis_result_blob])
            agent.active_thread.add_commit(commit)

        client_handler.emitOverallSummarizationProgress({
            "globalCardId": cardId,
            "working_status": "end-summarize",
            "synthesized_summary": synthesized_summary,
        })
